import os
from datetime import datetime, timedelta
from typing import Dict, Any, List, Type

from dotenv import load_dotenv
from pydantic import BaseModel, Field
from crewai import Agent, Task, Crew, Process, LLM
from crewai.tools import BaseTool
from crewai.project import CrewBase, agent, task, crew

import firebase_admin
from firebase_admin import credentials, firestore

load_dotenv()

# Initialize Firebase if not already initialized
if not firebase_admin._apps:
    try:
        cred_path = os.path.join(os.path.dirname(__file__), '..', 'mumbaihacks-63c0c-firebase-adminsdk-fbsvc-a7a6cd0780.json')
        if os.path.exists(cred_path):
            cred = credentials.Certificate(cred_path)
            firebase_admin.initialize_app(cred)
        else:
            firebase_admin.initialize_app()
    except Exception as e:
        print(f"Firebase initialization error: {e}")

db = firestore.client()

# API Key rotation for rate limiting
API_KEYS = [
    os.getenv("GEMINI_API_KEY"),
    os.getenv("GEMINI_API_KEY2"),
    os.getenv("GEMINI_API_KEY3"),
    os.getenv("GEMINI_API_KEY4")
]
API_KEYS = [key for key in API_KEYS if key]
current_api_key_index = 0

def get_next_api_key():
    global current_api_key_index
    if not API_KEYS:
        return None
    current_api_key_index = (current_api_key_index + 1) % len(API_KEYS)
    return API_KEYS[current_api_key_index]

def get_current_api_key():
    if not API_KEYS:
        return None
    return API_KEYS[current_api_key_index]

# Initialize Google Gemini using CrewAI's LLM with current API key
llm = LLM(
    model="gemini/gemini-2.5-flash-lite",
    temperature=0.1,
    api_key=get_current_api_key()
)


class FetchUserFinancialsInput(BaseModel):
    user_id: str = Field(description="The user ID to load financial summaries and goals")

class UpdateGoalInput(BaseModel):
    user_id: str = Field(description="The user ID")
    goal_id: str = Field(description="The goal document ID to update")
    updates: dict = Field(description="Fields to merge into goal doc")

class CreateAlertInput(BaseModel):
    user_id: str = Field(description="The user ID")
    message: str = Field(description="Human-friendly alert message")
    email_content: str = Field(description="Email body content generated by agent")
    risk_level: str = Field(description="Risk level reflecting feasibility decision")


class FetchUserFinancialsTool(BaseTool):
    name: str = "fetch_user_financials"
    description: str = "Fetch income, expenses (last 30 days), estimated savings balance, and existing goals with monthly commitments."
    args_schema: Type[BaseModel] = FetchUserFinancialsInput

    def _run(self, user_id: str) -> dict:
        try:
            from datetime import timezone
            transactions_ref = db.collection('users').document(user_id).collection('transactions')
            docs = transactions_ref.order_by('date', direction=firestore.Query.DESCENDING).limit(1000).stream()
            now = datetime.now(timezone.utc)
            start_date = now - timedelta(days=30)

            total_income = 0.0
            total_expenses = 0.0
            for doc in docs:
                data = doc.to_dict()
                d = data.get('date') or data.get('timestamp')
                try:
                    if isinstance(d, str):
                        # Parse string date (YYYY-MM-DD or ISO format)
                        if 'T' in d or 'Z' in d or '+' in d:
                            dt = datetime.fromisoformat(d.replace('Z', '+00:00'))
                        else:
                            # Simple date format like "2025-10-21" - make it timezone-aware
                            dt = datetime.fromisoformat(d).replace(tzinfo=timezone.utc)
                    elif hasattr(d, 'isoformat'):
                        # Firestore timestamp - ensure timezone aware
                        dt = d if d.tzinfo else d.replace(tzinfo=timezone.utc)
                    else:
                        dt = now
                except Exception as e:
                    print(f"‚ö†Ô∏è Date parsing error for transaction: {e}")
                    dt = now

                if dt >= start_date:
                    amt = float(data.get('amount') or 0)
                    if (data.get('type') or '').lower() == 'credit':
                        total_income += amt
                    else:
                        total_expenses += amt

            goals_ref = db.collection('users').document(user_id).collection('goals')
            goals_docs = goals_ref.stream()
            existing_goals: List[Dict[str, Any]] = []
            total_commitments = 0.0
            for gdoc in goals_docs:
                g = gdoc.to_dict()
                mc = float(g.get('monthly_contribution') or 0)
                total_commitments += mc
                existing_goals.append({
                    'id': g.get('id') or gdoc.id,
                    'title': g.get('title'),
                    'target_amount': float(g.get('target_amount') or 0),
                    'current_amount': float(g.get('current_amount') or 0),
                    'monthly_contribution': mc,
                    'duration_months': g.get('duration_months')
                })

            savings_balance = max(0.0, total_income - total_expenses)

            result = {
                'income': total_income,
                'expenses': total_expenses,
                'savings_balance': savings_balance,
                'existing_goals': existing_goals,
                'total_monthly_commitments': total_commitments
            }
            print(f"‚úÖ Financials fetched for {user_id}: {result}")
            return result
        except Exception as e:
            print(f"‚ùå Error fetching user financials: {e}")
            return {
                'income': 0.0,
                'expenses': 0.0,
                'savings_balance': 0.0,
                'existing_goals': [],
                'total_monthly_commitments': 0.0
            }


class UpdateGoalTool(BaseTool):
    name: str = "update_goal"
    description: str = "Update goal document fields in Firestore under users/{user_id}/goals/{goal_id}."
    args_schema: Type[BaseModel] = UpdateGoalInput

    def _run(self, user_id: str, goal_id: str, updates: dict) -> dict:
        try:
            goal_ref = db.collection('users').document(user_id).collection('goals').document(goal_id)
            updates = {**(updates or {}), 'updated_at': datetime.now().isoformat()}
            goal_ref.set(updates, merge=True)
            print(f"‚úÖ Goal updated {goal_id} for user {user_id}: {updates}")
            return {"success": True}
        except Exception as e:
            print(f"‚ùå Error updating goal: {e}")
            return {"success": False, "error": str(e)}


class CreateAlertTool(BaseTool):
    name: str = "create_alert"
    description: str = "Create a top-level alert document for goals with email content and metadata."
    args_schema: Type[BaseModel] = CreateAlertInput

    def _run(self, user_id: str, message: str, email_content: str, risk_level: str) -> dict:
        try:
            alert_ref = db.collection('alerts').document()
            alert_data = {
                'user_id': user_id,
                'alert_type': 'goals',
                'type': 'goals',
                'message': message,
                'created_at': datetime.now().isoformat(),
                'read': False,
                'email_content': email_content,
                'email_sent': False,
                'risk_level': risk_level
            }
            alert_ref.set(alert_data)
            print(f"‚úÖ Goal alert created for user {user_id}")
            return {"success": True}
        except Exception as e:
            print(f"‚ùå Error creating alert: {e}")
            return {"success": False, "error": str(e)}


class GoalAnalysisResult(BaseModel):
    """Comprehensive goal analysis result combining feasibility and progress"""
    feasible: bool
    monthly_contribution: float
    risk_level: str
    reason: str
    completion_months: int
    progress_updated: bool
    ai_insights: str
    recommendations: List[str]


@CrewBase
class GoalsCrew():
    agents_config = "../config/goals_agents.yaml"
    tasks_config = "../config/goals_tasks.yaml"

    @agent
    def goal_analysis_agent(self) -> Agent:
        return Agent(
            config=self.agents_config['goal_analysis_agent'],
            llm=llm,
            verbose=True,
            tools=[FetchUserFinancialsTool(), UpdateGoalTool(), CreateAlertTool()],
            max_retry_limit=3  # Retry up to 3 times on errors
        )

    @task
    def goal_analysis_task(self) -> Task:
        return Task(
            config=self.tasks_config['goal_analysis_task'],
            output_pydantic=GoalAnalysisResult,  # Use output_pydantic for better parsing
        )

    @crew
    def crew(self) -> Crew:
        return Crew(
            agents=self.agents,
            tasks=self.tasks,
            process=Process.sequential,
            verbose=True
        )


async def analyze_goal(user_id: str, goal_data: Dict[str, Any], context: str = "create") -> Dict[str, Any]:
    """
    Unified function to analyze goals for creation, updates, or payment verification.
    Runs both feasibility and progress agents collaboratively.

    Args:
        user_id: The user ID
        goal_data: Goal data dictionary
        context: "create", "update", or "payment" to indicate the scenario
    """
    import time
    max_retries = 3
    retry_delay = 2  # Start with 2 seconds
    
    for attempt in range(max_retries):
        try:
            print(f"üéØ Starting unified goal analysis ({context}) for user {user_id} goal {goal_data.get('title')} [Attempt {attempt + 1}/{max_retries}]")

            title = goal_data.get('title', '')
            target_amount = float(goal_data.get('target_amount') or 0)
            current_amount = float(goal_data.get('current_amount') or 0)
            duration_months = int(goal_data.get('duration_months') or 0)
            priority = goal_data.get('priority') or 'medium'
            category = goal_data.get('category') or 'general'

            crew_instance = GoalsCrew()
            crew = crew_instance.crew()
            result = crew.kickoff(inputs={
                'user_id': user_id,
                'goal_id': goal_data.get('id'),
                'goal_title': title,
                'target_amount': target_amount,
                'current_amount': current_amount,
                'duration_months': duration_months,
                'priority': priority,
                'category': category,
                'context': context
            })

            # Get the comprehensive analysis result from single task
            analysis = result.tasks_output[0].pydantic if result.tasks_output else None

            analysis_result = {
                'feasible': bool(analysis.feasible) if analysis else False,
                'monthly_contribution': float(analysis.monthly_contribution) if analysis else 0.0,
                'risk_level': analysis.risk_level if analysis else 'unknown',
                'reason': analysis.reason if analysis else '',
                'completion_months': int(analysis.completion_months) if analysis else 0,
                'progress_updated': bool(analysis.progress_updated) if analysis else False,
                'ai_insights': analysis.ai_insights if analysis else '',
                'recommendations': analysis.recommendations if analysis else [],
                'context': context
            }

            print(f"‚úÖ Comprehensive analysis complete ({context}): feasible={analysis_result['feasible']}, risk={analysis_result['risk_level']}")
            return analysis_result

        except Exception as e:
            error_str = str(e)
            # Check if it's a 503 error (model overloaded)
            if '503' in error_str or 'overloaded' in error_str.lower():
                print(f"‚ö†Ô∏è API overloaded (503) on attempt {attempt + 1}/{max_retries}")
                
                if attempt < max_retries - 1:
                    # Rotate to next API key
                    next_key = get_next_api_key()
                    global llm
                    llm = LLM(
                        model="gemini/gemini-2.5-flash-lite",
                        temperature=0.1,
                        api_key=next_key
                    )
                    print(f"üîÑ Rotated to API key {current_api_key_index + 1}, retrying in {retry_delay}s...")
                    time.sleep(retry_delay)
                    retry_delay *= 2  # Exponential backoff
                    continue
                else:
                    print(f"‚ùå All retry attempts exhausted")
            
            print(f"‚ùå Error in unified goal analysis ({context}): {e}")
            return {
                'feasible': False,
                'monthly_contribution': 0.0,
                'risk_level': 'unknown',
                'reason': error_str,
                'completion_months': 0,
                'progress_updated': False,
                'ai_insights': '',
                'recommendations': [],
                'context': context
            }
    
    # If we exhausted all retries
    print(f"‚ùå Failed after {max_retries} attempts")
    return {
        'feasible': False,
        'monthly_contribution': 0.0,
        'risk_level': 'unknown',
        'reason': 'API overloaded after multiple retry attempts',
        'completion_months': 0,
        'progress_updated': False,
        'ai_insights': '',
        'recommendations': [],
        'context': context
    }